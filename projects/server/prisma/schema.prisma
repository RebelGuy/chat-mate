// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["interactiveTransactions"]
  binaryTargets   = ["native"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

/// Persists access tokens for twitch authentication
model TwitchAuth {
  // there can only be one access token per client
  clientId String @id

  accessToken         String
  refreshToken        String
  expiresIn           Int
  obtainmentTimestamp BigInt
  scope               String

  @@map("twitch_auth")
}

// there is no notion of a "livestream" on twitch - all chat messages are sent to the channel directly.
// since we never run a twitch livestream without also running a youtube livestream, we point the twitch
// livestream to the youtube livestream.
model Livestream {
  id        Int            @id @default(autoincrement())
  liveId    String         @db.VarChar(11) // unique
  createdAt DateTime       @default(now())
  start     DateTime?
  end       DateTime?
  type      LivestreamType

  // if false, we don't listen to messages anymore (e.g. for when a livestream has concluded)
  isActive Boolean

  // for fetching the youtube chat of this livestream
  continuationToken String? @db.VarChar(1023)

  liveViewers   LiveViewers[]
  chatMessages  ChatMessage[]
  viewingBlocks ViewingBlock[]

  @@unique([liveId], map: "Livestream_liveId_key")
  @@map("livestream")
}

enum LivestreamType {
  publicLivestream
}

model LiveViewers {
  id               Int      @id @default(autoincrement())
  time             DateTime @default(now())
  youtubeViewCount Int
  twitchViewCount  Int

  livestreamId Int
  livestream   Livestream @relation(fields: [livestreamId], references: [id], map: "LiveViewers_livestreamId_fkey")

  @@index([livestreamId], map: "LiveViewers_livestreamId_fkey")
  @@map("liveviewers")
}

/// USERS

model ChatUser {
  id Int @id @default(autoincrement())

  // the channels associated with the user
  youtubeChannels YoutubeChannel[]
  twitchChannels  TwitchChannel[]

  chatMessages               ChatMessage[]
  experienceTransactions     ExperienceTransaction[]
  experienceSnapshots        ExperienceSnapshot[]
  viewingBlocks              ViewingBlock[]
  experienceDataAdministered ExperienceDataAdmin[]
  receivedPunishments        Punishment[]            @relation("punishments_user")
  administeredPunishments    Punishment[]            @relation("punishments_adminUser")

  @@map("chat_users")
}

model YoutubeChannelInfo {
  id          Int     @id @default(autoincrement())
  name        String  @db.VarChar(255)
  imageUrl    String  @db.VarChar(511)
  isOwner     Boolean
  isModerator Boolean
  isVerified  Boolean

  /// first seen with this info
  time DateTime

  channelId Int
  channel   YoutubeChannel @relation(fields: [channelId], references: [id], map: "youtube_channel_info_channelId_fkey")

  @@index([channelId], map: "youtube_channel_info_channelId_fkey")
  @@map("youtube_channel_info")
}

model YoutubeChannel {
  id        Int    @id @default(autoincrement())
  youtubeId String @db.VarChar(63) // unique

  userId Int
  user   ChatUser @relation(fields: [userId], references: [id], map: "youtube_channel_userId_fkey")

  infoHistory  YoutubeChannelInfo[]
  chatMessages ChatMessage[]

  @@unique([youtubeId], map: "youtube_channel_youtubeId_key")
  @@index([userId], map: "youtube_channel_userId_fkey")
  @@map("youtube_channel")
}

model TwitchChannelInfo {
  id Int @id @default(autoincrement())

  userName      String  @db.VarChar(64)
  displayName   String  @db.VarChar(64)
  userType      String  @db.VarChar(32)
  isBroadcaster Boolean
  isSubscriber  Boolean
  isMod         Boolean
  isVip         Boolean
  colour        String  @db.VarChar(8)

  /// first seen with this info
  time DateTime

  channelId Int
  channel   TwitchChannel @relation(fields: [channelId], references: [id], map: "twitch_channel_info_channelId_fkey")

  @@index([channelId], map: "twitch_channel_info_channelId_fkey")
  @@map("twitch_channel_info")
}

model TwitchChannel {
  id       Int    @id @default(autoincrement())
  twitchId String @db.VarChar(32) // unique

  userId Int
  user   ChatUser @relation(fields: [userId], references: [id], map: "twitch_channels_userId_fkey")

  infoHistory  TwitchChannelInfo[]
  chatMessages ChatMessage[]

  @@unique([twitchId], map: "twitch_channels_twitchId_key")
  @@index([userId], map: "twitch_channels_userId_fkey")
  @@map("twitch_channels")
}

model TwitchFollower {
  id          Int      @id @default(autoincrement())
  twitchId    String   @db.VarChar(32) // unique
  date        DateTime @default(now())
  userName    String
  displayName String

  @@unique([twitchId], map: "twitch_followers_twitchId_key")
  @@map("twitch_followers")
}

// CHAT

/// Unlike text, emoji objects are finite and can be re-used
model ChatEmoji {
  id          Int     @id @default(autoincrement())
  externalId  String  @db.VarChar(255) // unique
  imageUrl    String? @db.VarChar(511)
  imageWidth  Int?    @db.SmallInt
  imageHeight Int?    @db.SmallInt
  name        String? @db.VarChar(127)
  label       String? @db.VarChar(127)

  // for youtube only - currently unused
  isCustomEmoji Boolean

  messageParts ChatMessagePart[]

  // any custom emojis that have replaced this YouTube emoji within a chat message
  customEmoji ChatCustomEmoji[]

  @@unique([externalId], map: "chat_emoji_externalId_key")
  @@map("chat_emoji")
}

model ChatText {
  id        Int     @id @default(autoincrement())
  isBold    Boolean
  isItalics Boolean
  // YouTube imposes a chat message limit of 200 characters, and Twitch 500
  text      String  @db.VarChar(500)

  // technically messagePart should always be defined
  messagePart ChatMessagePart?

  // this text object may refer to a custom emoji
  customEmoji ChatCustomEmoji?

  @@map("chat_text")
}

model ChatCheer {
  id       Int    @id @default(autoincrement())
  amount   Int
  name     String @db.VarChar(64)
  colour   String @db.VarChar(8)
  imageUrl String @db.VarChar(512)

  // technically messagePart should always be defined
  messagePart ChatMessagePart?

  @@map("chat_cheers")
}

model ChatCustomEmoji {
  id Int @id @default(autoincrement())

  // keep the original objects in case the emoji symbol changes.
  textId Int? // unique
  text   ChatText? @relation(fields: [textId], references: [id], map: "chat_custom_emoji_textId_fkey")

  emojiId Int?
  emoji   ChatEmoji? @relation(fields: [emojiId], references: [id], map: "chat_custom_emoji_emojiId_fkey")

  customEmojiId Int
  customEmoji   CustomEmoji @relation(fields: [customEmojiId], references: [id], map: "chat_custom_emoji_customEmojiId_fkey")

  ChatMessagePart ChatMessagePart[]

  @@unique([textId], map: "chat_custom_emoji_textId_key")
  @@index([emojiId], map: "chat_custom_emoji_emojiId_fkey")
  @@index([customEmojiId], map: "chat_custom_emoji_customEmojiId_fkey")
  @@map("chat_custom_emoji")
}

/// Has exactly one text, emoji, or cheer component attached, and possibly also a custom emoji in addition to the other three.
model ChatMessagePart {
  id    Int @id @default(autoincrement())
  order Int // unique with `chatMessageId`

  chatMessageId Int // unique with `order`
  chatMessage   ChatMessage @relation(fields: [chatMessageId], references: [id], map: "chat_message_part_chatMessageId_fkey")

  textId Int? // unique
  text   ChatText? @relation(fields: [textId], references: [id], map: "chat_message_part_textId_fkey")

  emojiId Int?
  emoji   ChatEmoji? @relation(fields: [emojiId], references: [id], map: "chat_message_part_emojiId_fkey")

  cheerId Int? // unique
  cheer   ChatCheer? @relation(fields: [cheerId], references: [id], map: "chat_message_part_cheerId_fkey")

  customEmojiId Int?
  customEmoji   ChatCustomEmoji? @relation(fields: [customEmojiId], references: [id], map: "chat_message_part_customEmojiId_fkey")

  // all message parts of the chat message must have a different ordering
  @@unique([order, chatMessageId], map: "chat_message_part_order_chatMessageId_key")
  @@unique([textId], map: "chat_message_part_textId_key")
  @@unique([cheerId], map: "chat_message_part_cheerId_fkey")
  @@index([chatMessageId], map: "chat_message_part_chatMessageId_fkey")
  @@index([emojiId], map: "chat_message_part_emojiId_fkey")
  @@index([customEmojiId], map: "chat_message_part_customEmojiId_fkey")
  @@map("chat_message_part")
}

model ChatMessage {
  id         Int      @id @default(autoincrement())
  externalId String   @db.VarChar(255) // unique
  time       DateTime

  /// For Youtube messages only - required to retrieve the list of and execute options in the context menu next to messages.
  /// Internally in Youtube, this is called the `contextMenuEndpointParams`.
  contextToken String? @db.VarChar(511)

  userId Int
  user   ChatUser @relation(fields: [userId], references: [id], map: "chat_message_userId_fkey")

  // youtube and twitch ids are used to ensure we know what actual platform account authored the message
  youtubeChannelId Int?
  youtubeChannel   YoutubeChannel? @relation(fields: [youtubeChannelId], references: [id], map: "chat_message_youtubeChannelId_fkey")

  twitchChannelId Int?
  twitchChannel   TwitchChannel? @relation(fields: [twitchChannelId], references: [id], map: "chat_message_twitchChannelId_fkey")

  // null if the message was received off-stream. this is generally only true when received on twitch
  livestreamId Int?
  livestream   Livestream? @relation(fields: [livestreamId], references: [id], map: "chat_message_livestreamId_fkey")

  chatMessageParts          ChatMessagePart[]
  experienceDataChatMessage ExperienceDataChatMessage?

  @@unique([externalId], map: "chat_message_externalId_key")
  @@index([userId], map: "chat_message_userId_fkey")
  @@index([youtubeChannelId], map: "chat_message_youtubeChannelId_fkey")
  @@index([twitchChannelId], map: "chat_message_twitchChannelId_fkey")
  @@index([livestreamId], map: "chat_message_livestreamId_fkey")
  @@map("chat_message")
}

// Experience

/// Holds individual changes in a person's experience.
model ExperienceTransaction {
  id    Int      @id @default(autoincrement())
  time  DateTime
  delta Int

  // Exactly one of the below experience data columns will always be defined,
  // depending on what kind of event triggered this transaction.
  experienceDataChatMessage ExperienceDataChatMessage?
  experienceDataAdmin       ExperienceDataAdmin?

  userId Int
  user   ChatUser @relation(fields: [userId], references: [id], map: "experience_transaction_userId_fkey")

  @@index([userId], map: "experience_transaction_userId_fkey")
  @@map("experience_transaction")
}

/// Holds snapshots of a person's experience at certaint points in time.
model ExperienceSnapshot {
  id         Int      @id @default(autoincrement())
  time       DateTime
  experience Int

  userId Int
  user   ChatUser @relation(fields: [userId], references: [id], map: "experience_snapshot_userId_fkey")

  @@index([userId], map: "experience_snapshot_userId_fkey")
  @@map("experience_snapshot")
}

/// Data for an experience transaction triggered by a chat message
model ExperienceDataChatMessage {
  id Int @id @default(autoincrement())

  baseExperience                Int
  viewershipStreakMultiplier    Float
  participationStreakMultiplier Float
  spamMultiplier                Float
  messageQualityMultiplier      Float
  repetitionPenalty             Float? // todo: add data migration (default value is 0) and make required

  chatMessageId Int // unique
  chatMessage   ChatMessage @relation(fields: [chatMessageId], references: [id], map: "experience_data_chat_message_chatMessageId_fkey")

  experienceTransactionId Int // unique
  experienceTransaction   ExperienceTransaction @relation(fields: [experienceTransactionId], references: [id], map: "experience_data_chat_message_experienceTransactionId_fkey")

  @@unique([chatMessageId], map: "experience_data_chat_message_chatMessageId_key")
  @@unique([experienceTransactionId], map: "experience_data_chat_message_experienceTransactionId_key")
  @@map("experience_data_chat_message")
}

/// Data for an experience transaction triggered by an admin
model ExperienceDataAdmin {
  id Int @id @default(autoincrement())

  message String? @db.VarChar(1023)

  adminUserId Int
  adminUser   ChatUser @relation(fields: [adminUserId], references: [id], map: "experience_data_admin_adminUserId_fkey")

  experienceTransactionId Int // unique
  experienceTransaction   ExperienceTransaction @relation(fields: [experienceTransactionId], references: [id], map: "experience_data_admin_experienceTransactionId_fkey")

  // @@index([adminUserId], map: "experience_data_admin_adminUserId_fkey")
  @@unique([experienceTransactionId], map: "experience_data_admin_experienceTransactionId_key")
  @@index([adminUserId], map: "experience_data_admin_adminUserId_fkey")
  @@map("experience_data_admin")
}

/// Represents a continuous period of time in which a user has been viewing a livestream.
model ViewingBlock {
  id Int @id @default(autoincrement())

  startTime  DateTime
  lastUpdate DateTime

  livestreamId Int
  livestream   Livestream @relation(fields: [livestreamId], references: [id], map: "viewing_block_livestreamId_fkey")

  userId Int
  user   ChatUser @relation(fields: [userId], references: [id], map: "viewing_block_userId_fkey")

  @@index([livestreamId], map: "viewing_block_livestreamId_fkey")
  @@index([userId], map: "viewing_block_userId_fkey")
  @@map("viewing_block")
}

model CustomEmoji {
  id Int @id @default(autoincrement())

  symbol String @db.VarChar(10)
  name   String @db.VarChar(63)

  // max 64KB of storage
  image Bytes @db.Blob

  levelRequirement Int @db.UnsignedSmallInt

  ChatCustomEmoji ChatCustomEmoji[]

  @@unique([symbol], map: "CustomEmoji_symbol_key")
  @@map("customemoji")
}

model Punishment {
  id Int @id @default(autoincrement())

  punishmentType PunishmentType
  issuedAt       DateTime
  /// null if punishment never expires
  expirationTime DateTime?
  message        String?        @db.VarChar(1024)

  /// only set if the punishments has been revoked
  revokedTime   DateTime?
  revokeMessage String?   @db.VarChar(1024)

  userId Int
  user   ChatUser @relation("punishments_user", fields: [userId], references: [id], map: "punishments_userId_fkey")

  adminUserId Int
  adminUser   ChatUser @relation("punishments_adminUser", fields: [adminUserId], references: [id], map: "punishments_adminUserId_fkey")

  @@index([userId], map: "punishments_userId_fkey")
  @@index([adminUserId], map: "punishments_adminUserId_fkey")
  @@map("punishments")
}

enum PunishmentType {
  ban
  timeout
  mute
}
