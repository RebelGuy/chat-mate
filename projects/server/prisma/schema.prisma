// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["interactiveTransactions"]
  binaryTargets   = ["native", "debian-openssl-1.1.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

/// Persists access tokens for twitch authentication
model TwitchAuth {
  id Int @id @default(autoincrement())

  /// Only allowed to be null (temporarily) for the admin account.
  twitchUserId String?

  /// Must be set for the admin account.
  twitchUsername String

  accessToken         String
  refreshToken        String
  expiresIn           Int
  obtainmentTimestamp BigInt
  scope               String

  @@unique([twitchUserId], map: "twitch_auth_twitchUserId_key")
  @@unique([twitchUsername], map: "twitch_auth_twitchUsername_key")
  @@map("twitch_auth")
}

/// Persists access tokens for Youtube authentication
model YoutubeAuth {
  channelId   String   @id
  accessToken String   @db.VarChar(511)
  updateTime  DateTime

  @@map("youtube_auth")
}

// there is no notion of a "livestream" on twitch - all chat messages are sent to the channel directly.
// since we never run a twitch livestream without also running a youtube livestream, we point the twitch
// livestream to the youtube livestream.
model Livestream {
  id        Int       @id @default(autoincrement())
  liveId    String    @db.VarChar(11) // unique
  createdAt DateTime  @default(now())
  start     DateTime?
  end       DateTime?

  // if false, we don't listen to messages anymore (e.g. for when a livestream has concluded/not yet started)
  isActive Boolean

  // for fetching the youtube chat of this livestream
  continuationToken String? @db.VarChar(1023)

  streamerId Int
  streamer   Streamer @relation(fields: [streamerId], references: [id], map: "livestream_streamerId_fkey")

  liveViewers  LiveViewers[]
  chatMessages ChatMessage[]

  @@unique([liveId], map: "livestream_liveId_key")
  @@index([streamerId], map: "livestream_streamerId_fkey")
  @@map("livestream")
}

model LiveViewers {
  id               Int      @id @default(autoincrement())
  time             DateTime @default(now())
  youtubeViewCount Int
  twitchViewCount  Int

  livestreamId Int
  livestream   Livestream @relation(fields: [livestreamId], references: [id], map: "live_viewer_livestreamId_fkey")

  @@index([livestreamId], map: "live_viewer_livestreamId_fkey")
  @@map("live_viewer")
}

/// USERS

model ChatUser {
  id Int @id @default(autoincrement())

  // the time at which the user was linked to an aggregate user, if any
  linkedAt DateTime?

  /// Never defined for aggregate chat users, and possibly defined for default chat users.
  aggregateChatUserId Int?
  aggregateChatUser   ChatUser? @relation(name: "aggregateChatUser", fields: [aggregateChatUserId], references: [id], map: "chat_user_aggregateChatUserId_fkey")

  // the channels associated with the user. Empty if this is an aggregate user
  youtubeChannel YoutubeChannel?
  twitchChannel  TwitchChannel?

  chatMessages                   ChatMessage[]
  experienceTransactions         ExperienceTransaction[] @relation("experience_transaction_user")
  originalExperienceTransactions ExperienceTransaction[] @relation("experience_transaction_originalUser")
  experienceSnapshots            ExperienceSnapshot[]
  experienceDataAdministered     ExperienceDataAdmin[]
  userRanks                      UserRank[]              @relation("user_rank_userId")
  administeredUserRanks          UserRank[]              @relation("user_rank_assignedByUserId")
  revokedUserRanks               UserRank[]              @relation("user_rank_revokedByUserId")
  donationLinks                  DonationLink[]          @relation("donation_link_linkedUser")
  originalDonationLinks          DonationLink[]          @relation("donation_link_originalLinkedUser")
  registeredUser                 RegisteredUser?
  linkAttemptForDefaultUser      LinkAttempt[]           @relation("link_attempt_defaultChatUser")
  linkAttemptForAggregateUser    LinkAttempt[]           @relation("link_attempt_aggregateChatUser")

  // only used if this is an aggregate user
  linkTokensAggregateUser LinkToken[] @relation("link_token_aggregateChatUser")

  // only used if this is a default user
  linkTokensDefaultUser LinkToken[] @relation("link_token_defaultChatUser")

  /// The chat users connected to this aggregate user. Empty if this is not an aggregate user.
  connectedChatUsers ChatUser[] @relation("aggregateChatUser")

  @@map("chat_user")
}

model LinkAttempt {
  id Int @id @default(autoincrement())

  startTime    DateTime
  endTime      DateTime?
  log          String    @db.VarChar(4096)
  // if you change the length, it must also be updated in the LinkStore.completeLinkAttempt method
  errorMessage String?   @db.VarChar(4096)
  /// If an error occurred, whether the link attempt has been given the all-clear by an admin so another link attempt can be made.
  released     Boolean   @default(true)
  type         LinkType

  // the user that we are linking
  defaultChatUserId Int
  defaultChatUser   ChatUser @relation(name: "link_attempt_defaultChatUser", fields: [defaultChatUserId], references: [id], map: "link_attempt_defaultChatUserId_fkey")

  // the user that we are linking to/unlinking from
  aggregateChatUserId Int
  aggregateChatUser   ChatUser @relation(name: "link_attempt_aggregateChatUser", fields: [aggregateChatUserId], references: [id], map: "link_attempt_aggregateChatUserId_fkey")

  // the link token will be attached if the link attempt was conducted as part of a command execution (as opposed to being initiated by an admin)
  linkTokenId Int?
  linkToken   LinkToken? @relation(fields: [linkTokenId], references: [id], map: "link_attempt_linkTokenId_fkey")

  @@unique([linkTokenId], map: "link_attempt_linkTokenId_fkey")
  @@index([defaultChatUserId], map: "link_attempt_defaultChatUserId_fkey")
  @@index([aggregateChatUserId], map: "link_attempt_aggregateChatUserId_fkey")
  @@map("link_attempt")
}

enum LinkType {
  link
  unlink
}

model LinkToken {
  id Int @id @default(autoincrement())

  token String // unique

  aggregateChatUserId Int
  aggregateChatUser   ChatUser @relation(name: "link_token_aggregateChatUser", fields: [aggregateChatUserId], references: [id], map: "link_token_aggregateChatUserId_fkey")

  defaultChatUserId Int
  defaultChatUser   ChatUser @relation(name: "link_token_defaultChatUser", fields: [defaultChatUserId], references: [id], map: "link_token_defaultChatUserId_fkey")

  // only defined if an attempt to link has already been made via this token
  linkAttempt LinkAttempt?

  @@unique([token], map: "link_token_token_key")
  @@index([aggregateChatUserId], map: "link_token_aggregateChatUserId_fkey")
  @@index([defaultChatUserId], map: "link_token_defaultChatUserId_fkey")
  @@map("link_token")
}

model RegisteredUser {
  id Int @id @default(autoincrement())

  username       String   @db.VarChar(32) // unique
  registeredAt   DateTime @default(now())
  hashedPassword String   @db.VarChar(64)

  aggregateChatUserId Int // unique
  aggregateChatUser   ChatUser @relation(fields: [aggregateChatUserId], references: [id], map: "registered_user_aggregateChatUserId_fkey")

  loginTokens          LoginToken[]
  streamer             Streamer?
  streamerApplications StreamerApplication[]

  @@unique([aggregateChatUserId], map: "registered_user_aggregateChatUserId_fkey")
  @@unique([username], map: "registered_user_username_key")
  @@map("registered_user")
}

model LoginToken {
  id Int @id @default(autoincrement())

  token String @db.VarChar(8) // unique

  registeredUserId Int
  registeredUser   RegisteredUser @relation(fields: [registeredUserId], references: [id], map: "login_token_registeredUserId_fkey")

  @@unique([token], map: "login_token_token_key")
  @@index([registeredUserId], map: "login_token_registeredUserId_fkey")
  @@map("login_token")
}

model Streamer {
  id Int @id @default(autoincrement())

  registeredUserId Int // unique
  registeredUser   RegisteredUser @relation(fields: [registeredUserId], references: [id], map: "streamer_registeredUserId_fkey")

  userRanks                  UserRank[]
  livestreams                Livestream[]
  customEmojis               CustomEmoji[]
  donations                  Donation[]
  streamlabsSocketToken      StreamlabsSocketToken?
  experienceTransactions     ExperienceTransaction[]
  experienceSnapshots        ExperienceSnapshot[]
  twitchFollowers            TwitchFollower[]
  chatMessages               ChatMessage[]
  streamerYoutubeChannelLink StreamerYoutubeChannelLink?
  streamerTwitchChannelLink  StreamerTwitchChannelLink?

  @@unique([registeredUserId], map: "streamer_registeredUserId_fkey")
  @@map("streamer")
}

model StreamerApplication {
  id Int @id @default(autoincrement())

  timeCreated DateTime @default(now())
  message     String   @db.VarChar(4095)

  timeClosed   DateTime?
  isApproved   Boolean?
  closeMessage String?   @db.VarChar(4095)

  registeredUserId Int
  registeredUser   RegisteredUser @relation(fields: [registeredUserId], references: [id], map: "streamer_application_registeredUserId_fkey")

  @@index([registeredUserId], map: "streamer_application_registeredUserId_fkey")
  @@map("streamer_application")
}

model YoutubeChannelInfo {
  id          Int     @id @default(autoincrement())
  name        String  @db.VarChar(255)
  imageUrl    String  @db.VarChar(511)
  isOwner     Boolean
  isModerator Boolean
  isVerified  Boolean

  /// first seen with this info
  time DateTime

  channelId Int
  channel   YoutubeChannel @relation(fields: [channelId], references: [id], map: "youtube_channel_info_channelId_fkey")

  @@index([channelId], map: "youtube_channel_info_channelId_fkey")
  @@map("youtube_channel_info")
}

model YoutubeChannel {
  id        Int    @id @default(autoincrement())
  youtubeId String @db.VarChar(63) // unique

  // always a default user
  userId Int
  user   ChatUser @relation(fields: [userId], references: [id], map: "youtube_channel_userId_fkey")

  infoHistory                YoutubeChannelInfo[]
  chatMessages               ChatMessage[]
  streamerYoutubeChannelLink StreamerYoutubeChannelLink?

  @@unique([youtubeId], map: "youtube_channel_youtubeId_key")
  @@unique([userId], map: "youtube_channel_userId_fkey")
  @@map("youtube_channel")
}

model TwitchChannelInfo {
  id Int @id @default(autoincrement())

  userName      String  @db.VarChar(64)
  displayName   String  @db.VarChar(64)
  userType      String  @db.VarChar(32)
  isBroadcaster Boolean
  isSubscriber  Boolean
  isMod         Boolean
  isVip         Boolean
  colour        String  @db.VarChar(8)

  /// first seen with this info
  time DateTime

  channelId Int
  channel   TwitchChannel @relation(fields: [channelId], references: [id], map: "twitch_channel_info_channelId_fkey")

  @@index([channelId], map: "twitch_channel_info_channelId_fkey")
  @@map("twitch_channel_info")
}

model TwitchChannel {
  id       Int    @id @default(autoincrement())
  twitchId String @db.VarChar(32) // unique

  // always a default user
  userId Int
  user   ChatUser @relation(fields: [userId], references: [id], map: "twitch_channel_userId_fkey")

  infoHistory               TwitchChannelInfo[]
  chatMessages              ChatMessage[]
  streamerTwitchChannelLink StreamerTwitchChannelLink?

  @@unique([twitchId], map: "twitch_channel_twitchId_key")
  @@unique([userId], map: "twitch_channel_userId_fkey")
  @@map("twitch_channel")
}

model StreamerYoutubeChannelLink {
  id Int @id @default(autoincrement())

  streamerId Int
  streamer   Streamer @relation(fields: [streamerId], references: [id], map: "streamer_youtube_channel_link_streamerId_fkey")

  youtubeChannelId Int
  youtubeChannel   YoutubeChannel @relation(fields: [youtubeChannelId], references: [id], map: "streamer_youtube_channel_link_youtubeChannelId_fkey")

  @@unique([streamerId], map: "streamer_youtube_channel_link_streamerId_fkey")
  @@unique([youtubeChannelId], map: "streamer_youtube_channel_link_youtubeChannelId_fkey")
  @@map("streamer_youtube_channel_link")
}

model StreamerTwitchChannelLink {
  id Int @id @default(autoincrement())

  streamerId Int
  streamer   Streamer @relation(fields: [streamerId], references: [id], map: "streamer_twitch_channel_link_streamerId_fkey")

  twitchChannelId Int
  twitchChannel   TwitchChannel @relation(fields: [twitchChannelId], references: [id], map: "streamer_twitch_channel_link_twitchChannelId_fkey")

  @@unique([streamerId], map: "streamer_twitch_channel_link_streamerId_fkey")
  @@unique([twitchChannelId], map: "streamer_twitch_channel_link_twitchChannelId_fkey")
  @@map("streamer_twitch_channel_link")
}

model TwitchFollower {
  id          Int      @id @default(autoincrement())
  twitchId    String   @db.VarChar(32) // unique
  date        DateTime @default(now())
  userName    String
  displayName String

  streamerId Int
  streamer   Streamer @relation(fields: [streamerId], references: [id], map: "twitch_follower_streamerId_fkey")

  @@unique([twitchId], map: "twitch_follower_twitchId_key")
  @@index([streamerId], map: "twitch_follower_streamerId_fkey")
  @@map("twitch_follower")
}

// CHAT

/// Unlike text, emoji objects are finite and can be re-used
model ChatEmoji {
  id          Int     @id @default(autoincrement())
  imageUrl    String? @db.VarChar(511) // url
  imageWidth  Int?    @db.SmallInt
  imageHeight Int?    @db.SmallInt
  name        String? @db.VarChar(127)
  label       String? @db.VarChar(127)

  // for youtube only - currently unused
  isCustomEmoji Boolean

  messageParts ChatMessagePart[]

  // any custom emojis that have replaced this YouTube emoji within a chat message
  customEmoji ChatCustomEmoji[]

  @@unique([imageUrl], map: "chat_emoji_imageUrl_key")
  @@map("chat_emoji")
}

model ChatText {
  id        Int     @id @default(autoincrement())
  isBold    Boolean
  isItalics Boolean
  // YouTube imposes a chat message limit of 200 characters, and Twitch 500
  text      String  @db.VarChar(500)

  // technically messagePart should always be defined
  messagePart ChatMessagePart?

  // this text object may refer to a custom emoji
  customEmoji ChatCustomEmoji?

  @@map("chat_text")
}

model ChatCheer {
  id       Int    @id @default(autoincrement())
  amount   Int
  name     String @db.VarChar(64)
  colour   String @db.VarChar(8)
  imageUrl String @db.VarChar(512)

  // technically messagePart should always be defined
  messagePart ChatMessagePart?

  @@map("chat_cheer")
}

model ChatCustomEmoji {
  id Int @id @default(autoincrement())

  // keep the original objects in case the emoji symbol changes.
  textId Int? // unique
  text   ChatText? @relation(fields: [textId], references: [id], map: "chat_custom_emoji_textId_fkey")

  emojiId Int?
  emoji   ChatEmoji? @relation(fields: [emojiId], references: [id], map: "chat_custom_emoji_emojiId_fkey")

  customEmojiVersionId Int
  customEmojiVersion   CustomEmojiVersion @relation(fields: [customEmojiVersionId], references: [id], map: "chat_custom_emoji_customEmojiVersionId_fkey")

  ChatMessagePart ChatMessagePart[]

  @@unique([textId], map: "chat_custom_emoji_textId_key")
  @@index([emojiId], map: "chat_custom_emoji_emojiId_fkey")
  @@index([customEmojiVersionId], map: "chat_custom_emoji_customEmojiVersionId_fkey")
  @@map("chat_custom_emoji")
}

model ChatCommand {
  id Int @id @default(autoincrement())

  /// The normalised text part of the chat message after the initial `!`
  normalisedCommandName String @db.VarChar(64)

  startTime DateTime?
  endTime   DateTime?

  // Only one of result or error can be set, and they are only set after the command has completed execution.
  // These text lengths are used in `CommandStore.ts` - don't change them here without also changing them there
  result String? @db.VarChar(1024)
  error  String? @db.VarChar(1024)

  chatMessageId Int // unique
  chatMessage   ChatMessage @relation(fields: [chatMessageId], references: [id], map: "chat_command_chatMessageId_fkey")

  @@unique([chatMessageId], map: "chat_command_chatMessageId_fkey")
  @@map("chat_command")
}

/// Has exactly one text, emoji, or cheer component attached, and possibly also a custom emoji in addition to the other three.
model ChatMessagePart {
  id    Int @id @default(autoincrement())
  order Int // unique with `chatMessageId`

  chatMessageId Int // unique with `order`
  chatMessage   ChatMessage @relation(fields: [chatMessageId], references: [id], map: "chat_message_part_chatMessageId_fkey")

  textId Int? // unique
  text   ChatText? @relation(fields: [textId], references: [id], map: "chat_message_part_textId_fkey")

  emojiId Int?
  emoji   ChatEmoji? @relation(fields: [emojiId], references: [id], map: "chat_message_part_emojiId_fkey")

  cheerId Int? // unique
  cheer   ChatCheer? @relation(fields: [cheerId], references: [id], map: "chat_message_part_cheerId_fkey")

  customEmojiId Int?
  customEmoji   ChatCustomEmoji? @relation(fields: [customEmojiId], references: [id], map: "chat_message_part_customEmojiId_fkey")

  // all message parts of the chat message must have a different ordering
  @@unique([order, chatMessageId], map: "chat_message_part_order_chatMessageId_key")
  @@unique([textId], map: "chat_message_part_textId_key")
  @@unique([cheerId], map: "chat_message_part_cheerId_fkey")
  @@index([chatMessageId], map: "chat_message_part_chatMessageId_fkey")
  @@index([emojiId], map: "chat_message_part_emojiId_fkey")
  @@index([customEmojiId], map: "chat_message_part_customEmojiId_fkey")
  @@map("chat_message_part")
}

model ChatMessage {
  id         Int      @id @default(autoincrement())
  /// Either the Youtube Id, Twitch Id, or (for donations) Streamlabs Id
  externalId String   @db.VarChar(255) // unique
  time       DateTime

  /// For Youtube messages only - required to retrieve the list of and execute options in the context menu next to messages.
  /// Internally in Youtube, this is called the `contextMenuEndpointParams`.
  contextToken String? @db.VarChar(511)

  streamerId Int
  streamer   Streamer @relation(fields: [streamerId], references: [id], map: "chat_message_streamerId_fkey")

  // the user that sent the message, if known.
  // this is always set for livestream messages, that is, if either the `youtubeChannelId` or `twitchChannelId` is set.
  userId Int?
  user   ChatUser? @relation(fields: [userId], references: [id], map: "chat_message_userId_fkey")

  // youtube and twitch ids are used to ensure we know what actual platform account authored the message.
  // it is possible that they are both null - in that case, this is not a regular livestream message
  // (probably it is a donation message - see below)
  // note that we need to link the channel directly; linking to the user is not enough to determine the author's channel,
  // because the user may be an aggregate user.
  youtubeChannelId Int?
  youtubeChannel   YoutubeChannel? @relation(fields: [youtubeChannelId], references: [id], map: "chat_message_youtubeChannelId_fkey")

  twitchChannelId Int?
  twitchChannel   TwitchChannel? @relation(fields: [twitchChannelId], references: [id], map: "chat_message_twitchChannelId_fkey")

  // null if the message was received off-stream. this is generally only true when received on twitch
  livestreamId Int?
  livestream   Livestream? @relation(fields: [livestreamId], references: [id], map: "chat_message_livestreamId_fkey")

  // the donation that this message belongs to, if any
  donationId Int? // unique
  donation   Donation? @relation(fields: [donationId], references: [id], map: "chat_message_donationId_fkey")

  chatMessageParts          ChatMessagePart[]
  experienceDataChatMessage ExperienceDataChatMessage?
  chatCommand               ChatCommand?

  @@unique([externalId], map: "chat_message_externalId_key")
  @@unique([donationId], map: "chat_message_donationId_fkey")
  @@index([streamerId], map: "chat_message_streamerId_fkey")
  @@index([userId], map: "chat_message_userId_fkey")
  @@index([youtubeChannelId], map: "chat_message_youtubeChannelId_fkey")
  @@index([twitchChannelId], map: "chat_message_twitchChannelId_fkey")
  @@index([livestreamId], map: "chat_message_livestreamId_fkey")
  @@map("chat_message")
}

// Experience

/// Holds individual changes in a person's experience.
model ExperienceTransaction {
  id    Int      @id @default(autoincrement())
  time  DateTime
  delta Int

  // Exactly one of the below experience data columns will always be defined,
  // depending on what kind of event triggered this transaction.
  experienceDataChatMessage ExperienceDataChatMessage?
  experienceDataAdmin       ExperienceDataAdmin?

  /// The user to which the experience is currently linked to
  userId Int
  user   ChatUser @relation(name: "experience_transaction_user", fields: [userId], references: [id], map: "experience_transaction_userId_fkey")

  /// The user to which the experience was originally linked to. If null, the experience has not been re-linked and the original user is implied to be identical to the current user.
  originalUserId Int?
  originalUser   ChatUser? @relation(name: "experience_transaction_originalUser", fields: [userId], references: [id], map: "experience_transaction_originalUserId_fkey")

  streamerId Int
  streamer   Streamer @relation(fields: [streamerId], references: [id], map: "experience_transaction_streamerId_fkey")

  @@index([userId], map: "experience_transaction_userId_fkey")
  @@index([originalUserId], map: "experience_transaction_originalUserId_fkey")
  @@index([userId, time], map: "experience_transaction_userId_time_key")
  @@index([streamerId], map: "experience_transaction_streamerId_fkey")
  @@map("experience_transaction")
}

/// Holds snapshots of a person's experience at certaint points in time.
model ExperienceSnapshot {
  id         Int      @id @default(autoincrement())
  time       DateTime
  experience Int

  userId Int
  user   ChatUser @relation(fields: [userId], references: [id], map: "experience_snapshot_userId_fkey")

  streamerId Int
  streamer   Streamer @relation(fields: [streamerId], references: [id], map: "experience_snapshot_streamerId_fkey")

  @@index([userId], map: "experience_snapshot_userId_fkey")
  @@index([streamerId], map: "experience_snapshot_streamerId_fkey")
  @@map("experience_snapshot")
}

/// Data for an experience transaction triggered by a chat message
model ExperienceDataChatMessage {
  id Int @id @default(autoincrement())

  // if you add any new fields to this, be sure to update the `ExperienceStore.updateChatExperiences()` method
  baseExperience                Int
  /// Deprecated - only used before v1.23
  viewershipStreakMultiplier    Float
  participationStreakMultiplier Float
  spamMultiplier                Float
  messageQualityMultiplier      Float
  repetitionPenalty             Float? // todo: add data migration (default value is 0) and make required

  chatMessageId Int // unique
  chatMessage   ChatMessage @relation(fields: [chatMessageId], references: [id], map: "experience_data_chat_message_chatMessageId_fkey")

  experienceTransactionId Int // unique
  experienceTransaction   ExperienceTransaction @relation(fields: [experienceTransactionId], references: [id], map: "experience_data_chat_message_experienceTransactionId_fkey")

  @@unique([chatMessageId], map: "experience_data_chat_message_chatMessageId_key")
  @@unique([experienceTransactionId], map: "experience_data_chat_message_experienceTransactionId_key")
  @@map("experience_data_chat_message")
}

/// Data for an experience transaction triggered by an admin
model ExperienceDataAdmin {
  id Int @id @default(autoincrement())

  message String? @db.VarChar(1023)

  adminUserId Int
  adminUser   ChatUser @relation(fields: [adminUserId], references: [id], map: "experience_data_admin_adminUserId_fkey")

  experienceTransactionId Int // unique
  experienceTransaction   ExperienceTransaction @relation(fields: [experienceTransactionId], references: [id], map: "experience_data_admin_experienceTransactionId_fkey")

  @@unique([experienceTransactionId], map: "experience_data_admin_experienceTransactionId_key")
  @@index([adminUserId], map: "experience_data_admin_adminUserId_fkey")
  @@map("experience_data_admin")
}

model CustomEmoji {
  id Int @id @default(autoincrement())

  symbol String @db.VarChar(32) // unique

  streamerId Int
  streamer   Streamer @relation(fields: [streamerId], references: [id], map: "custom_emoji_streamerId_key")

  customEmojiVersions      CustomEmojiVersion[]
  customEmojiRankWhitelist CustomEmojiRankWhitelist[]

  @@unique([streamerId, symbol], map: "custom_emoji_streamerId_symbol_key")
  @@index([streamerId], map: "custom_emoji_streamerId_key")
  @@map("custom_emoji")
}

// this table has a BEFORE INSERT trigger `TRG_CHECK_EXISTING_ACTIVE_VERSION`
model CustomEmojiVersion {
  id Int @id @default(autoincrement())

  isActive   Boolean
  modifiedAt DateTime @default(now())
  version    Int

  name String @db.VarChar(63)

  // max 64KB of storage
  image Bytes @db.Blob

  levelRequirement        Int     @db.UnsignedSmallInt
  canUseInDonationMessage Boolean

  customEmojiId Int
  customEmoji   CustomEmoji @relation(fields: [customEmojiId], references: [id], map: "custom_emoji_customEmojiId_fkey")

  chatCustomEmojis ChatCustomEmoji[]

  @@unique([customEmojiId, version], map: "custom_emoji_version_customEmojiId_version_key")
  @@map("custom_emoji_version")
}

model CustomEmojiRankWhitelist {
  id Int @id @default(autoincrement())

  customEmojiId Int
  customEmoji   CustomEmoji @relation(fields: [customEmojiId], references: [id], map: "custom_emoji_rank_whitelist_customEmojiId_fkey")

  rankId Int
  rank   Rank @relation(fields: [rankId], references: [id], map: "custom_emoji_rank_whitelist_rankId_fkey")

  @@unique([customEmojiId, rankId])
  @@map("custom_emoji_rank_whitelist")
}

// Ranks

model Rank {
  id Int @id @default(autoincrement())

  name                 RankName
  displayNameNoun      String    @db.VarChar(64)
  displayNameAdjective String    @db.VarChar(64)
  description          String?   @db.VarChar(1024)
  group                RankGroup

  userRanks                UserRank[]
  customEmojiRankWhitelist CustomEmojiRankWhitelist[]

  @@unique([name], map: "rank_name_key")
  @@map("rank")
}

enum RankName {
  admin
  owner
  mod

  famous

  mute
  timeout
  ban

  donator
  supporter
  member
}

enum RankGroup {
  cosmetic
  administration
  punishment
  donation
}

// this table has a BEFORE INSERT trigger `TRG_CHECK_EXISTING_ACTIVE_RANK`
model UserRank {
  id Int @id @default(autoincrement())

  issuedAt       DateTime
  /// `null` if rank never expires
  expirationTime DateTime?
  /// optional assignment message
  message        String?   @db.VarChar(1024)

  /// only set if the rank has been revoked. acts as a "deactivated" flag
  revokedTime   DateTime?
  /// optional revocation message
  revokeMessage String?   @db.VarChar(1024)

  rankId Int
  rank   Rank @relation(fields: [rankId], references: [id], map: "user_rank_rankId_fkey")

  userId Int
  user   ChatUser @relation("user_rank_userId", fields: [userId], references: [id], map: "user_rank_userId_fkey")

  /// the streamer context to which this user rank belongs to. if null, the rank applies globally.
  streamerId Int?
  streamer   Streamer? @relation(fields: [streamerId], references: [id], map: "user_rank_streamerId_fkey")

  /// if null, was assigned by the system
  assignedByUserId Int?
  assignedByUser   ChatUser? @relation("user_rank_assignedByUserId", fields: [assignedByUserId], references: [id], map: "user_rank_assignedByUserId_fkey")

  /// if null, was revoked by the system. only relevant when `revokedTime` is non-null, or the rank has expired
  revokedByUserId Int?
  revokedByUser   ChatUser? @relation("user_rank_revokedByUserId", fields: [revokedByUserId], references: [id], map: "user_rank_revokedByUserId_fkey")

  @@index([rankId], map: "user_rank_rankId_fkey")
  @@index([userId], map: "user_rank_userId_fkey")
  @@index([streamerId], map: "user_rank_streamerId_fkey")
  @@index([expirationTime], map: "user_rank_expirationTime_key")
  @@index([revokedTime], map: "user_rank_revokedTime_key")
  @@map("user_rank")
}

model Donation {
  id Int @id @default(autoincrement())

  streamlabsId     Int // unique
  streamlabsUserId Int?
  time             DateTime
  currency         String
  amount           Float
  formattedAmount  String
  name             String   @db.VarChar(256)

  streamerId Int
  streamer   Streamer @relation(fields: [streamerId], references: [id], map: "donation_streamerId_fkey")

  chatMessage ChatMessage?

  @@unique([streamlabsId], map: "donation_streamlabsId_key")
  @@index([streamerId], map: "donation_streamerId_fkey")
  @@map("donation")
}

/// The streamers' streamlabs socket tokens found at https://streamlabs.com/dashboard#/settings/api-settings
model StreamlabsSocketToken {
  id Int @id @default(autoincrement())

  time  DateTime @default(now())
  token String   @db.VarChar(1024)

  streamerId Int // unique - every streamer can have at most one websocket token
  streamer   Streamer @relation(fields: [streamerId], references: [id], map: "streamlabs_socket_token_streamerId_fkey")

  @@unique([streamerId], map: "streamlabs_socket_token_streamerId_fkey")
  @@map("streamlabs_socket_token")
}

model DonationLink {
  id Int @id @default(autoincrement())

  linkIdentifier String // unique

  linkedAt DateTime

  /// The user to which the link identifier is currently linked to
  linkedUserId Int
  linkedUser   ChatUser @relation(name: "donation_link_linkedUser", fields: [linkedUserId], references: [id], map: "donation_link_linkedUserId_fkey")

  /// The user to which the link identifier was originally linked to. If null, the link identifier has not been re-linked and the original user is implied to be identical to the current user.
  originalLinkedUserId Int?
  originalLinkedUser   ChatUser? @relation(name: "donation_link_originalLinkedUser", fields: [originalLinkedUserId], references: [id], map: "donation_link_originalLinkedUserId_fkey")

  @@unique([linkIdentifier], map: "donation_link_linkIdentifier_key")
  // one-to-one mapping
  @@unique([linkIdentifier, linkedUserId], map: "donation_link_linkIdentifier_linkedUserId_key")
  @@index([originalLinkedUserId], map: "donation_link_originalLinkedUserId_fkey")
  @@map("donation_link")
}
